
1. PureComponent just superficially examines props and state before re-rendering. and Component always re-renders when its props or state change. 
 -  when the component's props or state contain complex data structures or objects that are being mutated, PureComponent may not behave as expected.

2.  Context+ ShouldComponentUpdate can be dangerous because it can cause unexpected re-renders and performance issues, because context  pass data down the component tree without going through intermediate components.

3. Information can be pass from component to it parent through Callback function, Props drilling, Context API.
   - Callback can pass data from the parent component to the child component as a prop
   -  Data can be pass through intermediate components using props drilling
   - Context API can be used to pass data through the component tree without having to pass props down manually at every level.

4. ShouldComponentUpdate  and Memoization
   - ShouldComponentUpdate  can be used to prevent re-rendering of a component if the props or state have not changed.
   - Memoization can be used to prevent re-rendering of a component if the props or state have not changed. (React.memo())

5. fragment is a way to group elements together without adding an extra node to the DOM. It is useful when you need to return multiple elements from a component's render method.
  - fragment without a key prop could potentially break your application if the order of the elements changes.

6. WithData, WithError, WithState 

7. Promises, callbacks, and async/await provides different approaches for handling exceptions in JavaScript.
  - Promises can use .catch() to handle errors.
    myPromise.then((result) => {
      // display result or do something with it
    }).catch((error) => {
      // handling error
    });
  - Callbacks can use try/catch to handle errors.
    function myCallback(error, result) {
      if (error) {
        // handling error
      } else {
        // display result or do something with it
      }
    }
  - Async/await can use try/catch to handle errors.
    async function filterOptions() {
      try {
        const filtered = await myPromise;
        // display result or do something with it
      } catch (error) {
        // handling error
      }
    }

8. setState takes in two arguments.
   - setState is  asynchronous because it is not guaranteed that the state will be updated immediately after the setState function is called.

9. Migrating a class component to a function component steps. 
   - Identify the component that needs to be migrated and its corresponding file.
   - Identify the state and side effects in the component.
   - Remove the render() method and the constructor.
   - Replace the state with the useState hook.
   - Remove the " this " keyword and use function arguments instead.

10. Styles can be applied to components in several ways.
     - Inline styles
     - CSS stylesheets
     - CSS-in-JS
     - CSS modules

11. dangerouslySetInnerHTML  allows you to render HTML as a string. It is useful when you need to render HTML that is not generated by React.
